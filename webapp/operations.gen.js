import axios from 'axios';
import { getIntrospectionQuery } from 'graphql';
import fs from 'fs/promises';
import path from 'path';
import { exec } from 'child_process';
import pluralize from 'pluralize';

const ENDPOINT =
  'https://green-feather-41451536.ap-south-1.aws.cloud.dgraph.io/graphql'; // TODO: Move this to environment variable

async function fetchSchema() {
  try {
    const introspectionQuery = getIntrospectionQuery();
    const response = await axios.post(ENDPOINT, { query: introspectionQuery });
    const schemaData = response.data.data;

    console.log('Schema fetched successfully.');
    await generateOperations(schemaData);
    await generateIndexFiles('./src/documents');
    await prettifyAllFiles('./src/documents');
    console.log('All operations generated and prettified.');
  } catch (error) {
    console.error('Error fetching schema:', error);
  }
}

async function generateOperations(schemaData) {
  const types = schemaData.__schema.types;
  const queries = types.find((type) => type.name === 'Query')?.fields || [];
  const mutations =
    types.find((type) => type.name === 'Mutation')?.fields || [];

  for (const query of queries) {
    await generateOperation(query, 'query', schemaData);
  }

  for (const mutation of mutations) {
    await generateOperation(mutation, 'mutation', schemaData);
  }
}

async function generateOperation(field, operationType, schemaData) {
  const operationName = capitalize(field.name);
  const constantName = toUpperSnakeCase(operationName);
  const kebabName = toKebabCase(field.name);

  // Create a map for variable names
  const variableMap = new Map();
  const usedVarNames = new Set();

  // Process variables to ensure uniqueness
  field.args.forEach((arg) => {
    let varName = arg.name;
    let counter = 1;

    while (usedVarNames.has(varName)) {
      varName = `${arg.name}_${counter}`;
      counter++;
    }

    usedVarNames.add(varName);
    variableMap.set(arg.name, varName);
  });

  // Generate variable declarations
  const args = Array.from(variableMap.entries())
    .map(
      ([_, varName]) =>
        `$${varName}: ${formatType(field.args.find((arg) => variableMap.get(arg.name) === varName).type)}`
    )
    .join(', ');

  // Generate selection set with variable mapping
  const selectionSet = generateSelectionSet(
    field.type,
    schemaData,
    2,
    new Set(),
    variableMap
  );

  const resourceName = getResourceName(field.name);
  const outputDir = path.join(
    './src/documents',
    resourceName,
    `${operationType}`
  );

  await fs.mkdir(outputDir, { recursive: true });

  const operationDocument = `
    // THIS FILE IS AUTOGENERATED. DO NOT EDIT.
    import { gql } from '@apollo/client';

    export const ${constantName} = gql\`
    ${operationType} ${operationName}(${args}) {
      ${field.name}(${field.args.map((arg) => `${arg.name}: $${variableMap.get(arg.name)}`).join(', ')}) {
        ${selectionSet}
      }
    }
    \`;
  `;

  const outputPath = path.join(outputDir, `${kebabName}.ts`);
  await fs.writeFile(outputPath, operationDocument);
  console.log(`Generated ${operationType}: ${field.name}`);
}

async function generateIndexFiles(dir) {
  const files = await fs.readdir(dir, { withFileTypes: true });
  const exportStatements = [];

  for (const file of files) {
    const filePath = path.join(dir, file.name);

    if (file.isDirectory()) {
      await generateIndexFiles(filePath);
    } else if (file.name.endsWith('.ts')) {
      const fileNameWithoutExt = file.name.replace('.ts', '');
      exportStatements.push(`export * from './${fileNameWithoutExt}';`);
    }
  }

  if (exportStatements.length > 0) {
    const indexPath = path.join(dir, 'index.ts');

    await fs.writeFile(indexPath, exportStatements.join('\n'));
    console.log(`Generated index.ts in ${dir}`);
  }
}

async function prettifyFile(filePath) {
  return new Promise((resolve, reject) => {
    exec(`npx prettier --write ${filePath}`, (error, stdout, stderr) => {
      if (error) {
        console.error(`Error prettifying ${filePath}:`, error);
        reject(error);
      } else {
        console.log(`Prettified: ${filePath}`);
        resolve(stdout);
      }
    });
  });
}

async function prettifyAllFiles(dir) {
  const files = await fs.readdir(dir, { withFileTypes: true });

  for (const file of files) {
    const filePath = path.join(dir, file.name);

    if (file.isDirectory()) {
      await prettifyAllFiles(filePath);
    } else if (file.name.endsWith('.ts')) {
      await prettifyFile(filePath);
    }
  }
}

function generateSelectionSet(
  type,
  schemaData,
  depth = 2,
  seenTypes = new Set(),
  variableMap = new Map()
) {
  if (depth === 0) return '';

  // Track seen types to prevent infinite recursion
  const typeName = type.name || (type.ofType && type.ofType.name);
  if (seenTypes.has(typeName)) return '';

  let actualType = type;
  while (actualType.ofType) {
    actualType = actualType.ofType; // Unwrap NON_NULL and LIST wrappers.
  }

  const targetType = schemaData.__schema.types.find(
    (t) => t.name === actualType.name
  );
  if (!targetType || !targetType.fields) return ''; // Return empty if no fields are found.

  return targetType.fields
    .map((field) => {
      let fieldType = field.type;
      while (fieldType.ofType) {
        fieldType = fieldType.ofType; // Unwrap field type (handle LIST, NON_NULL, etc.)
      }

      // For object types, always include a selection
      if (
        fieldType.kind === 'OBJECT' ||
        (fieldType.kind === 'LIST' && fieldType.ofType.kind === 'OBJECT')
      ) {
        const nestedSelection = generateSelectionSet(
          field.type,
          schemaData,
          depth - 1,
          new Set(seenTypes),
          variableMap
        );
        return nestedSelection ? `${field.name} { ${nestedSelection} }` : '';
      }

      // Recursively generate nested fields for deeper levels.
      seenTypes.add(typeName);
      const nestedSelection = generateSelectionSet(
        field.type,
        schemaData,
        depth - 1,
        new Set(seenTypes)
      );
      return nestedSelection
        ? `${field.name} {\n  ${nestedSelection}\n}`
        : field.name;
    })
    .filter(Boolean) // Remove empty selections.
    .join('\n  ');
}

function generateBasicFields(type, schemaData) {
  const targetType = schemaData.__schema.types.find(
    (t) => t.name === type.name
  );
  if (!targetType || !targetType.fields) return '';

  return targetType.fields
    .filter((field) => {
      let fieldType = field.type;
      while (fieldType.ofType) {
        fieldType = fieldType.ofType;
      }
      return fieldType.kind !== 'OBJECT' && fieldType.kind !== 'LIST';
    })
    .map((field) => field.name)
    .join('\n  ');
}

function formatType(type) {
  if (type.kind === 'NON_NULL') {
    return `${formatType(type.ofType)}!`;
  } else if (type.kind === 'LIST') {
    return `[${formatType(type.ofType)}]`;
  } else {
    return type.name || 'Any';
  }
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function toUpperSnakeCase(string) {
  return string.replace(/([a-z])([A-Z])/g, '$1_$2').toUpperCase();
}

function toKebabCase(string) {
  return string
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase();
}

function getResourceName(operationName) {
  const commonPrefixes = [
    'get',
    'add',
    'update',
    'delete',
    'create',
    'fetch',
    'query',
    'aggregate',
  ];

  for (const prefix of commonPrefixes) {
    if (operationName.startsWith(prefix)) {
      const resourcePart = operationName.replace(prefix, '');
      const resourceWords = resourcePart.match(/[A-Z][a-z]*/g);

      if (resourceWords) {
        const resourceName = resourceWords
          .map((word) => word.toLowerCase())
          .join('_');

        return pluralize(resourceName);
      }
    }
  }

  return 'common';
}

fetchSchema();
